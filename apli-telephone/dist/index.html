<!DOCTYPE html>
<html lang="fr">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="application-name" content="Boilerplate">

    <title>News</title>
    <link rel="stylesheet" href="css/main.css">
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
    <link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css"/>
    <script type="text/javascript" src="//cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js"></script>
</head>
<body>
    <div class="slider">
        <div class="page">
            <h1>santé</h1>
            <p>BPM : <div class="bpm"></div></p>
            <p>KM : <div class="kmFait"></div></p>
        </div>
        <div class="page">
            <h1>survie</h1>
            <p>Temps : <div class="Temps" id="log"></div></p>
            <p>Température : <div class="temperature"></div></p>
            <p>Nombre de kilomètres parcourus : <div class="nbKmDistance"></div></p>
        </div>
         <div class="page">
             <script>// URL: https://beta.observablehq.com/d/0268b2eb90be370b
             // Title: Zambezi
             // Author: Stev (@tarte0)
             // Version: 365
             // Runtime version: 1

             const m0 = {
                 id: "0268b2eb90be370b@365",
                 variables: [
                     {
                         inputs: ["md"],
                         value: (function(md){return(
                             md`# Zambezi`
                         )})
                     },
                     {
                         name: "canvas",
                         inputs: ["DOM","w","h","inputs","namibiaGeoFeatures","scale","margin","fillPolygon","transformWithScale","drawPolygon","pointInPolygon","mutable currentFeature","healthsites","transformPointWithScale"],
                         value: (function*(DOM,w,h,inputs,namibiaGeoFeatures,scale,margin,fillPolygon,transformWithScale,drawPolygon,pointInPolygon,$0,healthsites,transformPointWithScale)
                             {
                                 const canvas = DOM.canvas(w, h);
                                 const ctx = canvas.getContext('2d');

                                 canvas.addEventListener(
                                     "mousemove",
                                     function(e) {
                                         inputs.mousePos = [e.offsetX, e.offsetY];
                                     },
                                     false
                                 );

                                 const allPoints = []
                                 namibiaGeoFeatures.forEach(feature => {
                                     let d = feature.geometry;
                                     allPoints.push(...d);
                                 })

                                 const scaleInfo = scale(allPoints, w-margin, h-margin);

                                 ctx.font = "30px Arial";

                                 while(true){
                                     ctx.fillStyle = "white";
                                     ctx.fillRect(0,0,w,h);

                                     ctx.strokeStyle = "rbga(0,0,0,0.75)";

                                     namibiaGeoFeatures.forEach((feature,i) => {
                                         let d = feature.geometry;


                                         ctx.fillStyle = '#f0f0f0';
                                         fillPolygon(transformWithScale(d, w, h, margin, scaleInfo), ctx);
                                         drawPolygon(transformWithScale(d, w, h, margin, scaleInfo), ctx);

                                     })

                                     const selectedFeature = namibiaGeoFeatures.find(feature => {
                                         let d = feature.geometry;
                                         return pointInPolygon(transformWithScale(d, w, h, margin, scaleInfo), inputs.mousePos)
                                     })

                                     if(selectedFeature) {

                                         $0.value = selectedFeature

                                         ctx.fillStyle = "white";
                                         fillPolygon(transformWithScale(selectedFeature.geometry, w, h, margin, scaleInfo), ctx);

                                         ctx.lineWidth = 3;
                                         drawPolygon(transformWithScale(selectedFeature.geometry, w, h, margin, scaleInfo), ctx);

                                         ctx.fillStyle = "black";
                                         ctx.fillText(selectedFeature.properties.name.replace(/Region/, ''), inputs.mousePos[0], inputs.mousePos[1]);
                                     }

                                     healthsites.forEach((p,i) => {
                                         ctx.fillStyle = 'rgba(255,0,0,0.5)';
                                         ctx.lineWidth = 1;

                                         const transformedPoint = transformPointWithScale(p, w, h, margin, scaleInfo);

                                         ctx.beginPath();
                                         ctx.arc(transformedPoint[0], transformedPoint[1], 5, 0, Math.PI*2);
                                         ctx.fill();
                                         //ctx.stroke();

                                     })

                                     yield canvas;
                                 }
                             }
                         )
                     },
                     {

                     },
                     {
                         name: "initial currentFeature",
                         value: (function(){return(
                             null
                         )})
                     },
                     {
                         name: "mutable currentFeature",
                         inputs: ["Mutable","initial currentFeature"],
                         value: (M, _) => new M(_)
                     },
                     {
                         name: "currentFeature",
                         inputs: ["mutable currentFeature"],
                         value: _ => _.generator
                     },
                     {
                         name: "margin",
                         value: (function(){return(
                             20
                         )})
                     },
                     {

                     },
                     {
                         name: "color",
                         inputs: ["d3"],
                         value: (function(d3){return(
                             d3.interpolateOranges
                         )})
                     },
                     {

                     },
                     {
                         name: "getCoordsFromFeature",
                         value: (function(){return(
                             function getCoordsFromFeature(feature) {
                                 return {...feature, coords: feature.geometry.coordinates[0][0]};
                             }
                         )})
                     },
                     {
                         name: "namibiaGeoFeatures",
                         inputs: ["namibiaGeoJson"],
                         value: (function(namibiaGeoJson){return(
                             namibiaGeoJson.features.map(f => ({...f, geometry:f.geometry.coordinates[0][0].map(p=>[Math.abs(p[0]), Math.abs(p[1])])}))
                         )})
                     },
                     {

                     },
                     {

                     },
                     {
                         name: "scale",
                         inputs: ["getBoundingBox"],
                         value: (function(getBoundingBox){return(
                             function scale(coords, width, height) {
                                 const bounds = getBoundingBox(coords);
                                 const xScale = width / Math.abs(bounds.xMax - bounds.xMin);
                                 const yScale = height / Math.abs(bounds.yMax - bounds.yMin);
                                 const scale = xScale < yScale ? xScale : yScale;
                                 return {...bounds, scale};
                             }
                         )})
                     },
                     {
                         name: "transform",
                         inputs: ["scale"],
                         value: (function(scale){return(
                             function transform(coords, width, height, margin) {
                                 const scalingInfo = scale(coords, width-margin, height-margin);

                                 const xScale = (width - margin)/2 - ((scalingInfo.xMax - scalingInfo.xMin)/2 * scalingInfo.scale) + margin/2

                                 return coords.map(p =>
                                     [(p[0] - scalingInfo.xMin) * scalingInfo.scale + xScale, (p[1] - scalingInfo.yMin) * scalingInfo.scale + margin/2]
                                 )
                             }
                         )})
                     },
                     {
                         name: "transformWithScale",
                         value: (function(){return(
                             function transformWithScale(coords, width, height, margin, scalingInfo) {

                                 const xScale = (width - margin)/2 - ((scalingInfo.xMax - scalingInfo.xMin)/2 * scalingInfo.scale) + margin/2

                                 return coords.map(p =>
                                     [(p[0] - scalingInfo.xMin) * scalingInfo.scale + xScale, (p[1] - scalingInfo.yMin) * scalingInfo.scale + margin/2]
                                 )
                             }
                         )})
                     },
                     {
                         name: "transformPointWithScale",
                         value: (function(){return(
                             function transformPointWithScale(point, width, height, margin, scalingInfo) {

                                 const xScale = (width - margin)/2 - ((scalingInfo.xMax - scalingInfo.xMin)/2 * scalingInfo.scale) + margin/2

                                 return [(point[0] - scalingInfo.xMin) * scalingInfo.scale + xScale, (point[1] - scalingInfo.yMin) * scalingInfo.scale + margin/2]
                             }
                         )})
                     },
                     {
                         name: "getBoundingBox",
                         value: (function(){return(
                             function getBoundingBox(coords) {
                                 let xMin = coords[0][0];
                                 let xMax = -1;
                                 let yMin = coords[0][1];
                                 let yMax = -1;

                                 coords.forEach(p => {
                                     xMin = xMin > p[0] ? p[0] : xMin
                                     xMax = xMax < p[0] ? p[0] : xMax
                                     yMin = yMin > p[1] ? p[1] : yMin
                                     yMax = yMax < p[1] ? p[1] : yMax
                                 });

                                 return {xMin, xMax, yMin, yMax}
                             }
                         )})
                     },
                     {
                         name: "drawPolygon",
                         value: (function(){return(
                             (polygon, ctx) => {
                                 ctx.beginPath();
                                 ctx.moveTo(polygon[0][0], polygon[0][1]);
                                 for(let i=0; i<polygon.length; i++) {
                                     ctx.lineTo(polygon[i][0], polygon[i][1]);
                                 }
                                 ctx.lineTo(polygon[0][0], polygon[0][1]);
                                 ctx.closePath();
                                 ctx.stroke();
                             }
                         )})
                     },
                     {
                         name: "fillPolygon",
                         value: (function(){return(
                             (polygon, ctx) => {
                                 ctx.beginPath();
                                 ctx.moveTo(polygon[0][0], polygon[0][1]);
                                 for(let i=0; i<polygon.length; i++) {
                                     ctx.lineTo(polygon[i][0], polygon[i][1]);
                                 }
                                 ctx.lineTo(polygon[0][0], polygon[0][1]);
                                 ctx.closePath();
                                 ctx.fill();
                             }
                         )})
                     },
                     {
                         name: "pointInPolygon",
                         value: (function(){return(
                             (polygon, point) => {

                                 let inside = false; //no intersection for the moment (0 is even)
                                 for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                                     let xi = polygon[i][0], yi = polygon[i][1];
                                     let xj = polygon[j][0], yj = polygon[j][1];

                                     let intersect = ((yi > point[1]) != (yj > point[1]))
                                         && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                                     if (intersect) inside = !inside; //odd number of intersections => inside
                                 }

                                 return inside;
                             }
                         )})
                     },
                     {

                     },
                     {
                         name: "w",
                         inputs: ["width"],
                         value: (function(width){return(
                             width
                         )})
                     },
                     {
                         name: "h",
                         inputs: ["w"],
                         value: (function(w){return(
                             w/2
                         )})
                     },
                     {

                     },
                     {

                     },
                     {
                         name: "namibiaGeoJson",
                         inputs: ["d3","namibiaGeoJsonURL"],
                         value: (function(d3,namibiaGeoJsonURL){return(
                             d3.json(namibiaGeoJsonURL)
                         )})
                     },
                     {
                         name: "healthsites",
                         inputs: ["d3"],
                         value: (async function(d3)
                             {
                                 let h = await d3.csv(
                                     "https://gist.githubusercontent.com/Zechasault/6f0220cdc647be560a930791799f5194/raw/b71686c7593c98948a6f0aec29ff581096f727b3/namibia-healthsites"
                                 );
                                 return h.map(d => [Math.abs(d.X), Math.abs(d.Y)]);
                             }
                         )
                     },
                     {

                     },
                     {
                         name: "inputs",
                         value: (function(){return(
                             {
                                 mousePos : {}
                             }
                         )})
                     },
                     {

                     },
                     {
                         name: "d3",
                         inputs: ["require"],
                         value: (function(require){return(
                             require('d3')
                         )})
                     },
                     {

                     },
                     {
                         name: "namibiaGeoJsonURL",
                         value: (function(){return(
                             `https://gist.githubusercontent.com/mostertg/68ddfb178b2aafafdcceb6afb73281db/raw/980b6f8ad402da2883b5fc793694dcc36fa1ef14/namibia-regions.json`
                         )})
                     },
                     {
                         name: "topojson",
                         inputs: ["require"],
                         value: (function(require){return(
                             require("topojson-client@3")
                         )})
                     }
                 ]
             };

             const notebook = {
                 id: "0268b2eb90be370b@365",
                 modules: [m0]
             };

             export default notebook;</script>
        </div>
    </div>


    <div class="page">
        <div class="envoieNews" visible="false">
            <h1> News </h1>
            <INPUT TYPE="text" NAME="input" VALUE="" CLASS="textBoxNews"/></BR>
            <INPUT TYPE="button" NAME="bouton" VALUE="Contrôler" CLASS="buttonNews"/>
        </div>
    </div>
<div class="buttonChatbot">X</div>
>>>>>>> master


    <iframe class="chatbot"
            allow="microphone;"
            width="350"
            height="430"
            src="https://console.dialogflow.com/api-client/demo/embedded/eab372df-9cad-4249-93a2-6a8394a0365d" style ="position : absolute;bottom: 0px;right: 0px;">
    </iframe>
	<script type="text/javascript" src="js/main.js"></script>
    <script>
        $(document).ready(function(){
          $('.slider').slick({
            arrows: false,
          });
        });
    </script>
</body>
</html>